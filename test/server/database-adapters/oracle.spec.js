const { OracleAdapter } = require('../../../server/database-adapters/oracle.js');

describe('Oracle database adapter', function () {
    describe('when connection is not ok', function () {
        const adapter = new OracleAdapter({ host: 'invalid-host' });

        describe('testConnection', function () {
            it('should throw', function () {
                return expect(adapter.testConnection()).rejects.toThrow();
            }, 20000);
        });

        describe('getCollectionNames', function () {
            it('should throw', function () {
                return expect(adapter.getCollectionNames()).rejects.toThrow();
            }, 20000);
        });

        describe('getCollectionSchema', function () {
            it('should throw', function () {
                return expect(adapter.getCollectionSchema('foo')).rejects.toThrow();
            }, 20000);
        });

        describe('getSqlQuerySchema', function () {
            it('should throw', function () {
                return expect(adapter.getSqlQuerySchema('SELECT * FROM foo')).rejects.toThrow();
            }, 20000);
        });
    });

    if (process.env.URUNGI_TEST_ORACLE) {
        describe('when connection is ok', function () {
            const params = JSON.parse(process.env.URUNGI_TEST_ORACLE);
            const adapter = new OracleAdapter(params);
            const tableData = require('./__data__/table-data.js');

            beforeAll(async function () {
                const connection = await adapter.getConnection();

                // DROP all tables
                const res = await connection.execute('SELECT TABLE_NAME FROM user_tables');
                for (const row of res.rows) {
                    await connection.execute(`DROP TABLE "${row.TABLE_NAME}" CASCADE CONSTRAINTS`);
                }

                await connection.execute('CREATE TABLE "artist" ("artist_id" NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY, "name" NVARCHAR2(1000))');
                await connection.execute('CREATE TABLE "album" ("album_id" NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY, "artist_id" NUMBER, "title" NVARCHAR2(1000), "release_date" DATE, "price" NUMBER(10, 2))');
                await connection.execute('CREATE TABLE "song" ("song_id" NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY, "album_id" NUMBER, "title" NVARCHAR2(1000))');

                for (const artist of tableData.artist) {
                    await connection.execute('INSERT INTO "artist" ("artist_id", "name") VALUES (:1, :2)', artist);
                }
                for (const album of tableData.album) {
                    await connection.execute('INSERT INTO "album" ("album_id", "artist_id", "title", "release_date", "price") VALUES (:1, :2, :3, :4, :5)', album);
                }
                for (const song of tableData.song) {
                    await connection.execute('INSERT INTO "song" ("song_id", "album_id", "title") VALUES (:1, :2, :3)', song);
                }

                await connection.commit();

                await connection.close();
            });

            describe('testConnection', function () {
                it('should resolve', function () {
                    return expect(adapter.testConnection()).resolves.toBeUndefined();
                });
            });

            describe('getCollectionNames', function () {
                it('should resolve to a list of collection names', function () {
                    const expected = ['album', 'artist', 'song'];

                    return expect(adapter.getCollectionNames()).resolves.toEqual(expected);
                });
            });

            describe('getCollectionSchema', function () {
                it('should return the list of columns of album', function () {
                    return expect(adapter.getCollectionSchema('album')).resolves.toEqual({
                        columns: [
                            { name: 'album_id', type: 'number' },
                            { name: 'artist_id', type: 'number' },
                            { name: 'title', type: 'string' },
                            { name: 'release_date', type: 'date' },
                            { name: 'price', type: 'number' },
                        ],
                    });
                });

                it('should return the list of columns of song', function () {
                    return expect(adapter.getCollectionSchema('song')).resolves.toEqual({
                        columns: [
                            { name: 'song_id', type: 'number' },
                            { name: 'album_id', type: 'number' },
                            { name: 'title', type: 'string' },
                        ],
                    });
                });
            });

            describe('getSqlQuerySchema', function () {
                it('should return the list of columns', function () {
                    const sql = 'SELECT "song"."song_id", "song"."title", "album"."title" AS "album_title", "album"."release_date" ' +
                        'FROM "song" JOIN "album" ON ("song"."album_id" = "album"."album_id")';

                    return expect(adapter.getSqlQuerySchema(sql)).resolves.toEqual({
                        columns: [
                            { name: 'song_id', type: 'number' },
                            { name: 'title', type: 'string' },
                            { name: 'album_title', type: 'string' },
                            { name: 'release_date', type: 'date' },
                        ],
                    });
                });

                it('should throw the error message returned by mysql', function () {
                    const sql = 'a';

                    return expect(adapter.getSqlQuerySchema(sql)).rejects.toThrow('missing SELECT keyword');
                });
            });

            describe('getQueryResults', function () {
                const tests = require('./__data__/tests.js')('oracle');
                it.each(tests)('%s', async function (name, query, expected) {
                    const results = await adapter.getQueryResults(query);

                    expect(results.data).toEqual(expected);
                });
            });
        });
    }
});
